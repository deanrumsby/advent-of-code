# Day 4: The Ideal Stocking Stuffer

```elixir
Mix.install([
  {:kino, "~> 0.12.3"}
])
```

## Input

```elixir
input = Kino.Input.textarea("Please paste your puzzle input:")
```

## Part 1

We need to keep generating hashes until we compute one that satisfies the given condition (it must start with five zeroes). We can use `Stream.unfold/2` to create an infinite stream of hashes, and then follow that with `Enum.find/2` to retrieve the first successful hash.

Whilst generating hashes with `Part1.hash/2` we return a tuple with the shape `{index, hash}` instead of returning just the hash value. I chose to do this as the index is needed as our answer, so we would like to keep hold of it throughout the calculations. Thus a hash in our context has this shape, and such when we check with `Part1.successful_hash/1`, or wish to return our index answer, we use `Kernel.elem/2` to use the correct values.

```elixir
defmodule Part1 do
  def successful_hash?(hash) do
    String.starts_with?(elem(hash, 1), "00000")
  end

  def hash(secret, index) do
    create_nonce(secret, index)
    |> then(fn nonce -> Base.encode16(:crypto.hash(:md5, nonce)) end)
    |> then(&{index, &1})
  end

  defp create_nonce(secret, index), do: secret <> Integer.to_string(index)
end
```

```elixir
secret = Kino.Input.read(input)

Stream.unfold(1, fn i -> {Part1.hash(secret, i), i + 1} end)
|> Enum.find(fn hash -> Part1.successful_hash?(hash) end)
|> elem(0)
```

## Part 2

For part 2 we can use the exact same strategy, we just have to update our check function into `Part2.successful_hash?/1` to use six zeroes.

On my machine the enumeration required to return the answer took a handful of seconds.

```elixir
defmodule Part2 do
  def successful_hash?(hash) do
    String.starts_with?(elem(hash, 1), "000000")
  end

  defdelegate hash(secret, index), to: Part1
end
```

```elixir
secret = Kino.Input.read(input)

Stream.unfold(1, fn i -> {Part2.hash(secret, i), i + 1} end)
|> Enum.find(fn hash -> Part2.successful_hash?(hash) end)
|> elem(0)
```
