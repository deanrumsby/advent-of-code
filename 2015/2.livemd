# Day 2: I Was Told There Would Be No Math

```elixir
Mix.install([
  {:kino, "~> 0.12.3"}
])
```

## Input

```elixir
input = Kino.Input.textarea("Please paste your puzzle input:")
```

## Shared Code

In both parts of this problem we will be parsing the input in exactly the same way. We take a string of dimensions eg `15x111x2` and parse it into a list of integers `[15, 111, 2]`. We can then use this list as arguments for calculating the various properties we need.

```elixir
defmodule Day2 do
  def parse_dimensions(str) do
    str
    |> String.split("x")
    |> Enum.map(&String.to_integer/1)
  end
end
```

## Part 1

We start part 1 by reading and parsing the puzzle input as mentioned above. We map the parsed input into an stream of integers representing the wrapping paper required for each present and then take the sum.

```elixir
defmodule Part1 do
  def wrapping_paper_required(l, w, h) do
    surface_area(l, w, h) + smallest_side_area(l, w, h)
  end

  defp surface_area(l, w, h), do: 2 * l * w + 2 * l * h + 2 * w * h
  defp smallest_side_area(l, w, h), do: Enum.min([l * w, l * h, w * h])
end
```

```elixir
import Day2
import Part1

input
|> Kino.Input.read()
|> String.split("\n")
|> Stream.map(&parse_dimensions/1)
|> Stream.map(fn args -> apply(&wrapping_paper_required/3, args) end)
|> Enum.sum()
```

## Part 2

For part 2 we are concerned with the ribbon needed for each present, so we swap out our map with our new rule, but otherwise the logic remains the same as in part 1.

```elixir
defmodule Part2 do
  def ribbon_required(l, w, h) do
    volume(l, w, h) + smallest_perimeter(l, w, h)
  end

  defp volume(l, w, h), do: l * w * h
  defp smallest_perimeter(l, w, h), do: Enum.min([2 * (l + w), 2 * (l + h), 2 * (w + h)])
end
```

```elixir
import Day2
import Part2

input
|> Kino.Input.read()
|> String.split("\n")
|> Stream.map(&parse_dimensions/1)
|> Stream.map(fn args -> apply(&ribbon_required/3, args) end)
|> Enum.sum()
```
