# Day 2: I Was Told There Would Be No Math

```elixir
Mix.install([
  {:kino, "~> 0.12.3"}
])
```

## Input

```elixir
input = Kino.Input.textarea("Please paste your puzzle input:")
```

## Shared Modules

````elixir
defmodule Box do
  defstruct l: 1, w: 1, h: 1

  @doc """
  Takes a list of dimensions and returns a Box

  ## Example
  ```elixir
  iex> Box.new([4, 5, 6])
  %Box{l: 4, w: 5, h: 6}
  ```
  """
  def new(list) do
    [l, w, h] = list
    %Box{l: l, w: w, h: h}
  end

  @doc """
  Calculates the surface area of the box

  ## Example
  ```elixir
  iex> Box.surface_area(%Box{l: 2, w: 2, h: 3})
  32
  ```
  """
  def surface_area(box) do
    2 * box.l * box.w + 2 * box.l * box.h + 2 * box.w * box.h
  end

  @doc """
  Calculates the smallest side area of the box

  ## Example
  ```elixir
  iex> Box.smallest_side_area(%Box{l: 1, w: 2, h: 3})
  2
  ```
  """
  def smallest_side_area(box) do
    Enum.min([box.l * box.w, box.l * box.h, box.w * box.h])
  end

  @doc """
  Calculates the volume of the box

  ## Example
  ```elixir
  iex> Box.volume(%Box{l: 2, w: 2, h: 4})
  16
  ```
  """
  def volume(box) do
    box.l * box.w * box.h
  end

  @doc """
  Calculates the smallest perimeter of the box

  ## Example
  ```elixir
  iex> Box.smallest_perimeter(%Box{l: 3, w: 2, h: 4})
  10
  ```
  """
  def smallest_perimeter(box) do
    Enum.min([2 * (box.l + box.w), 2 * (box.l + box.h), 2 * (box.w + box.h)])
  end
end
````

````elixir
defmodule Parser do
  @doc """
  Takes a string of "x" seperated dimensions and returns a Box

  ## Example
  ```elixir
  iex> Parser.parse_box("4x2x8")
  %Box{l: 4, w: 2, h: 8}
  ```
  """
  def parse_box(str) do
    str
    |> String.split("x")
    |> Enum.map(&String.to_integer/1)
    |> Box.new()
  end
end
````

## Part 1

````elixir
defmodule Part1 do
  @doc """
  Calculates the wrapping paper needed for a box

  ## Example
  ```elixir
  iex> Part1.wrapping_paper_required(%Box{l: 2, w: 2, h: 3})
  32 + 4
  """
  def wrapping_paper_required(box) do
    Box.surface_area(box) + Box.smallest_side_area(box)
  end
end
````

If we split our input on newline characters, we can then parse each line as a Box via `Parser.parse_box/1`. This allows us to use `Part1.wrapping_paper_required/1` to calculate the wrapping paper required for each box and sum as a reducer.

```elixir
input
|> Kino.Input.read()
|> String.split("\n")
|> Stream.map(&Parser.parse_box/1)
|> Enum.reduce(0, &(&2 + Part1.wrapping_paper_required(&1)))
```

## Part 2

````elixir
defmodule Part2 do
  @doc """
  Calculates the ribbon needed for a box

  ## Example
  ```elixir
  iex> Part2.ribbon_required(%Box{l: 2, w: 2, h: 3})
  12 + 8
  """
  def ribbon_required(box) do
    Box.volume(box) + Box.smallest_perimeter(box)
  end
end
````

For part 2 we use the exact same process as in part 1, although we swap our reducer with `Part2.ribbon_required/1` to calculate the total ribbon needed.

```elixir
input
|> Kino.Input.read()
|> String.split("\n")
|> Stream.map(&Parser.parse_box/1)
|> Enum.reduce(0, &(&2 + Part2.ribbon_required(&1)))
```
