# Day 2: I Was Told There Would Be No Math

```elixir
Mix.install([
  {:kino, "~> 0.12.3"}
])
```

## Input

```elixir
input = Kino.Input.textarea("Please paste your puzzle input:")
```

## Part 1

We start by creating a stream of parsed dimensions by splitting on newline characters and then processing each individual string of dimensions. I have created `Part1.parse_dimensions/1` for this purpose - it takes a string such as `"10x5x443"` and returns the list `[10, 5, 443]`. By mapping the dimensions to this list form we can then use `Kernel.apply/2` to use the dimensions as arguments for our function `Part1.wrapping_paper_required/3`. This leaves us with a stream of values corresponding to the wrapping paper needed for each present, which when summed results in our answer.

```elixir
defmodule Part1 do
  def parse_dimensions(str) do
    str
    |> String.split("x")
    |> Enum.map(&String.to_integer/1)
  end

  def wrapping_paper_required(l, w, h) do
    surface_area(l, w, h) + smallest_side_area(l, w, h)
  end

  defp surface_area(l, w, h), do: 2 * l * w + 2 * l * h + 2 * w * h
  defp smallest_side_area(l, w, h), do: Enum.min([l * w, l * h, w * h])
end
```

```elixir
input
|> Kino.Input.read()
|> String.split("\n")
|> Stream.map(&Part1.parse_dimensions/1)
|> Stream.map(fn dims -> apply(&Part1.wrapping_paper_required/3, dims) end)
|> Enum.sum()
```

## Part 2

For part 2 we are concerned with the ribbon needed for each present. We still parse the dimensions exactly the same as in part 1, so that function is delegated, and we provide `Part2.ribbon_required/3` to perform the necessary calculations on those dimensions.

```elixir
defmodule Part2 do
  defdelegate parse_dimensions(str), to: Part1

  def ribbon_required(l, w, h) do
    volume(l, w, h) + smallest_perimeter(l, w, h)
  end

  defp volume(l, w, h), do: l * w * h
  defp smallest_perimeter(l, w, h), do: Enum.min([2 * (l + w), 2 * (l + h), 2 * (w + h)])
end
```

```elixir
input
|> Kino.Input.read()
|> String.split("\n")
|> Stream.map(&Part2.parse_dimensions/1)
|> Stream.map(fn dims -> apply(&Part2.ribbon_required/3, dims) end)
|> Enum.sum()
```
